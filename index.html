<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TEOT Interpreter V2</title>
<style>
body { font-family: sans-serif; padding: 20px; background: #1e1e1e; color: #f0f0f0; }
textarea { width: 100%; height: 250px; background: #2e2e2e; color: #f0f0f0; border: none; padding: 10px; font-family: monospace; }
#output { white-space: pre-wrap; background: #2e2e2e; padding: 10px; margin-top: 10px; min-height: 150px; }
button { margin-top: 10px; padding: 10px 20px; }
</style>
</head>
<body>
<h1>The End of Time (TEOT) Interpreter</h1>
<textarea id="code" placeholder="Write your TEOT code here..."></textarea>
<br>
<button onclick="runTEOT()">Run</button>
<div id="output"></div>
<script>
async function runTEOT() {
    const outputEl = document.getElementById("output");
    outputEl.textContent = "";

    const code = document
        .getElementById("code")
        .value
        .split("\n")
        .map(l => l.trim())
        .filter(Boolean);

    let stack = [];
    let vars = {};
    let timeline = 0;

    function print(msg) {
        outputEl.textContent += msg + "\n";
    }

    async function asyncInput(promptMsg) {
        await new Promise(r => setTimeout(r, 0)); // yield to browser
        return prompt(promptMsg);
    }

    function evalExpr(expr) {
        expr = expr.trim();

        // ---- TEOT SPECIALS ----
        if (expr === "stack?") return stack.length > 0;
        if (expr === "stack") return stack.length;

        if (expr === "pop") {
            if (stack.length === 0) return null;
            return stack.pop();
        }

        // ---- Unary NOT ----
        if (expr.startsWith("!")) {
            return !evalExpr(expr.slice(1));
        }

        // ---- Binary operators ----
        const ops = ["==","!=","<=",">=","<",">","+","-","*","/","%","&","|"];
        for (const op of ops) {
            const parts = expr.split(op);
            if (parts.length === 2) {
                const a = evalExpr(parts[0]);
                const b = evalExpr(parts[1]);
                switch (op) {
                    case "+": return a + b;
                    case "-": return a - b;
                    case "*": return a * b;
                    case "/": return a / b;
                    case "%": return a % b;
                    case "==": return a == b;
                    case "!=": return a != b;
                    case "<": return a < b;
                    case ">": return a > b;
                    case "<=": return a <= b;
                    case ">=": return a >= b;
                    case "&": return a && b;
                    case "|": return a || b;
                }
            }
        }

        if (vars.hasOwnProperty(expr)) return vars[expr];
        if (!isNaN(Number(expr))) return Number(expr);

        if (expr.startsWith('"') && expr.endsWith('"')) {
            return expr.slice(1, -1);
        }

        return expr;
    }

    async function executeBlock(start) {
        let i = start;
        while (i < code.length) {
            let line = code[i];

            if (line === "}") return i;

            if (line === "reset") {
                timeline = 0;
                await new Promise(r => setTimeout(r, 0)); // critical
                return code.length;
            }

            if (line.startsWith("print(")) {
                print(evalExpr(line.slice(6, -1)));
            }

            else if (line.startsWith("var ")) {
                const [name, value] = line.slice(4).split("=");
                vars[name.trim()] = evalExpr(value);
            }

            else if (line.startsWith("push ")) {
                stack.push(evalExpr(line.slice(5)));
            }

            else if (line.includes("input(")) {
                const msg = line.match(/input\((.*)\)/)[1].replace(/"/g, "");
                vars["input"] = await asyncInput(msg);
            }

            else if (line.startsWith("if ")) {
                const cond = line.match(/if (.*)\?/)[1];
                if (evalExpr(cond)) {
                    i = await executeBlock(i + 2);
                } else {
                    while (i < code.length && !code[i].startsWith("else?")) i++;
                    if (code[i]?.startsWith("else?")) {
                        i = await executeBlock(i + 2);
                    }
                }
            }

            i++;
        }
        return i;
    }

    while (timeline < code.length) {
        const line = code[timeline++];

        if (line === "reset") {
            timeline = 0;
            await new Promise(r => setTimeout(r, 0));
        }

        else if (line.startsWith("if ")) {
            timeline = await executeBlock(timeline - 1);
        }

        else if (line.startsWith("print(")) {
            print(evalExpr(line.slice(6, -1)));
        }

        else if (line.startsWith("var ")) {
            const [name, value] = line.slice(4).split("=");
            vars[name.trim()] = evalExpr(value);
        }

        else if (line.startsWith("push ")) {
            stack.push(evalExpr(line.slice(5)));
        }

        else if (line.includes("input(")) {
            const msg = line.match(/input\((.*)\)/)[1].replace(/"/g, "");
            vars["input"] = await asyncInput(msg);
        }
    }
}
</script>
</body>
</html>
