<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TEOT Interpreter</title>
<style>
body { font-family: sans-serif; padding: 20px; background: #1e1e1e; color: #f0f0f0; }
textarea { width: 100%; height: 250px; background: #2e2e2e; color: #f0f0f0; border: none; padding: 10px; font-family: monospace; }
#output { white-space: pre-wrap; background: #2e2e2e; padding: 10px; margin-top: 10px; min-height: 150px; }
button { margin-top: 10px; padding: 10px 20px; }
</style>
</head>
<body>
<h1>The End of Time (TEOT) Interpreter</h1>
<textarea id="code" placeholder="Write your TEOT code here..."></textarea>
<br>
<button onclick="runTEOT()">Run</button>
<div id="output"></div>
<script>
async function runTEOT() {
    const outputEl = document.getElementById("output");
    outputEl.textContent = "";
    const code = document.getElementById("code").value.split("\n").map(l => l.trim()).filter(l => l);
    let stack = [];
    let vars = {};
    async function asyncInput(promptMsg) {
        return new Promise(resolve => {
            setTimeout(() => resolve(prompt(promptMsg)), 0);
        });
    }
    function print(msg) {
        outputEl.textContent += msg + "\n";
    }
    function applyOperators(a, op, b) {
        if (op === "+") return a + b;
        if (op === "-") return a - b;
        if (op === "*") return a * b;
        if (op === "/") return a / b;
        if (op === "%") return a % b;
        if (op === "==") return a == b;
        if (op === "!=") return a != b;
        if (op === "<") return a < b;
        if (op === ">") return a > b;
        if (op === "<=") return a <= b;
        if (op === ">=") return a >= b;
        if (op === "&") return a && b;
        if (op === "|") return a || b;
        return null;
    }
    function evalExpr(expr) {
        expr = expr.trim();
        if (expr.startsWith("!")) {
            return !evalExpr(expr.slice(1));
        }
        const binOps = ["==","!=","<=",">=","<",">","+","-","*","/","%","&","|"];
        for (let op of binOps) {
            let parts = expr.split(op);
            if (parts.length === 2) {
                let a = evalExpr(parts[0]);
                let b = evalExpr(parts[1]);
                return applyOperators(a, op, b);
            }
        }
        if (expr === "pop") {
            if (stack.length === 0) throw new Error("Pop from empty stack");
            return stack.pop();
        }
        if (vars[expr] !== undefined) return vars[expr];
        if (!isNaN(Number(expr))) return Number(expr);
        if (expr.startsWith('"') && expr.endsWith('"')) return expr.slice(1,-1);
        return expr;
    }
    async function executeBlock(lines, startIndex) {
        let i = startIndex;
        while (i < lines.length) {
            let line = lines[i];
            if (line === "}") break;
            if (line === "reset") {
                timeline = 0;
                return lines.length;
            }
            if (line.startsWith("print(")) {
                let content = line.match(/print\((.*)\)/)[1];
                print(evalExpr(content));
            } else if (line.startsWith("var ")) {
                let parts = line.split("=");
                let name = parts[0].replace("var","").trim();
                let value = evalExpr(parts[1]);
                vars[name] = value;
            } else if (line.startsWith("push ")) {
                stack.push(evalExpr(line.slice(5)));
            } else if (line === "stack") {
                vars["stack"] = stack.length;
            } else if (line.includes("input(")) {
                let promptMsg = line.match(/input\((.*)\)/)[1].replace(/"/g,"");
                vars["input"] = await asyncInput(promptMsg);
            } else if (line.startsWith("if ")) {
                let cond = line.match(/if (.*)\?/)[1];
                let condValue = evalExpr(cond);
                if (lines[i+1] === "{") i++;
                if (condValue) {
                    i = await executeBlock(lines, i+1);
                    while(i<lines.length && !lines[i].startsWith("}")) i++;
                } else {
                    let depth = 0;
                    while (i<lines.length) {
                        if (lines[i].includes("{")) depth++;
                        if (lines[i].includes("}")) { if(depth===0) break; depth--; }
                        if (lines[i].startsWith("elif") || lines[i].startsWith("else?")) break;
                        i++;
                    }
                }
            } else if (line.startsWith("elif ")) {
                let cond = line.match(/elif (.*)\?/)[1];
                let condValue = evalExpr(cond);
                if (lines[i+1] === "{") i++;
                if (condValue) {
                    i = await executeBlock(lines, i+1);
                    while(i<lines.length && !lines[i].startsWith("}")) i++;
                } else {
                    let depth = 0;
                    while (i<lines.length) {
                        if (lines[i].includes("{")) depth++;
                        if (lines[i].includes("}")) { if(depth===0) break; depth--; }
                        if (lines[i].startsWith("elif") || lines[i].startsWith("else?")) break;
                        i++;
                    }
                }
            } else if (line.startsWith("else?")) {
                if (lines[i+1] === "{") i++;
                i = await executeBlock(lines, i+1);
                while(i<lines.length && !lines[i].startsWith("}")) i++;
            }
            i++;
        }
        return i;
    }
    let timeline = 0;
    while (timeline < code.length) {
        let line = code[timeline];
        timeline++;
        if (line === "reset") {
            timeline = 0;
        } else if (line.startsWith("if ") || line.startsWith("elif ") || line.startsWith("else?")) {
            timeline = await executeBlock(code, timeline-1);
        } else if (line.startsWith("print(")) {
            let content = line.match(/print\((.*)\)/)[1];
            print(evalExpr(content));
        } else if (line.startsWith("var ")) {
            let parts = line.split("=");
            let name = parts[0].replace("var","").trim();
            let value = evalExpr(parts[1]);
            vars[name] = value;
        } else if (line.startsWith("push ")) {
            stack.push(evalExpr(line.slice(5)));
        } else if (line === "stack") {
            vars["stack"] = stack.length;
        } else if (line.includes("input(")) {
            let promptMsg = line.match(/input\((.*)\)/)[1].replace(/"/g,"");
            vars["input"] = await asyncInput(promptMsg);
        }
    }
}
</script>
</body>
</html>
